#!/usr/bin/python3
import sys
import io
import os
import pandas as pd
import getopt
import math
import matplotlib.pyplot as plt
import argparse

########################
# UDF's            
########################

# is_number function
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


# parse arguments
def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Plot specified columns from input data")

    parser.add_argument("-k", required=True, metavar='<col1,col2, ..>', 
    help="Columns to plot (comma-separated, 1-indexed)")

    parser.add_argument("-b", required=True, metavar='col', help="Column to use as x-axis (1-indexed)")

    parser.add_argument("-v", metavar='xaxis_value[,xaxis_value,...]', 
                       help="Position(s) of vertical line(s) on plot (comma-separated)")
    parser.add_argument("-l", metavar='<legend1,legend2,..>', help="Legend labels (comma-separated)")
    parser.add_argument("-t", metavar='title', help="Plot title")
    parser.add_argument("-f", action="store_true", help="Treat x-axis as categorical")
    
    return parser.parse_args()


########################
# MAIN PROGRAM
########################
if __name__ == "__main__":


    #---------------------
    # argument parsing
    #---------------------
    args = parse_arguments()

    # Parse column indices (convert to 0-indexed)
    cols_indx   = [int(x) - 1 for x in args.k.split(",")]
    base_indx   = int(args.b) - 1
    vbar_locs = args.v.split(',') if args.v else None
    user_legend = args.l.split(",") if args.l else None
    title = args.t if args.t else ""

    
    #---------------------
    # stdin processing
    #---------------------

    # Read the first line from stdin
    first_line = sys.stdin.readline()

    # Determine if there's a header
    header_opt = False

    if header_opt:
        header = 0
    elif True in [is_number(x) for x in first_line.split()]:
        header = None
    else:
        header = 0
        header_opt = True

    # Read the remaining content and prepend the first line
    remaining_content = sys.stdin.read()
    content = first_line + remaining_content

    # Create a file-like buffer with the content
    content_buffer = io.StringIO(content)

    # Read the data into a DataFrame
    df = pd.read_csv(content_buffer, sep='\s+', header=header)

    # Assign column names if there is no header
    if header_opt is False:
        df.columns = [ 'var' + str(i) for i in range(df.shape[1])]

    #---------------------
    # Plotting
    #---------------------
    if (isinstance(df.iloc[0, base_indx], str) or args.f):
        ## Space tick marks out if its a line plot based on the type of X
        ## or if -f is triggered
        xseries = [str(x) for x in df.iloc[:, base_indx]]
        label_span = math.ceil(df.shape[0] / 40)
        plt.plot(xseries, df.iloc[:, cols_indx ], marker=".") 
        plt.xticks(xseries[::label_span],  rotation=90)
    else:
        ## scatter plot (X is numeric )
        plt.plot(df.iloc[:, base_indx], df.iloc[:, cols_indx], marker=".") 
    
    ### zero line
    plt.axhline(y=0, color='black', ls='-', alpha=0.3)

    ### vertical lines
    if vbar_locs is not None:
        for vbar_loc in vbar_locs:
            if (isinstance(df.iloc[0, base_indx], str) or args.f):
                plt.axvline(x=vbar_loc, color='red', ls='-', alpha=0.5)
            else:
                plt.axvline(x=float(vbar_loc), color='red', ls='-', alpha=0.5)

    ### legend
    if user_legend:
        plt.legend(user_legend)
    else:
        plt.legend(df.columns[cols_indx])

    plt.subplots_adjust(bottom=0.15)
    plt.title(title)
    plt.show()

